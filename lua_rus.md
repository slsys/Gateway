[[toc]]
# Поддержка lua скриптов

## Введение
Шлюз SLS самодостаточен и может обходиться без внешних систем управления Умным домом. Для реализации автоматизаций, он поддерживает скриптовый язык программирования [LUA](https://ru.wikipedia.org/wiki/Lua).
При разработке скриптов можно использовать функции как встроенные в прошивку шлюза, так и функции поддерживаемых шлюзом библиотек LUA.
<!--	#ToDo - какие библиотеки встроены в прошивку
		известны из доков:
		os
		string
		table
		...
 -->
Текущая, поддерживаемая, версия [LUA 5.4.4](https://www.lua.org/versions.html#5.4) (с версии прошивки 2022.01.30d1). 
## Соглашения
Немного о форматировании и названиях различных объектов шлюза.

Для работы с различными объектами используется формат кода типа `zigbee.getStatus()`. В терминологии LUA это выглядит как `библиотека.функция()`. Поэтому постараемся придерживаться подобного именования объектов SLS.

Форматирование текста:
- пункты меню: *File -> Save* 
- небольшие куски кода: `print(a)`
- многострочный код:
```lua
local var = 0
print(var)
```
Описание синтаксиса:
```lua
function("var1(STR)", var2(INT)[, var3(BOOL)])
-- в скобках после имени переменной указан её тип
-- если тип не указан, значит можно передавать любой
-- если переменная указана в кавчках, значит ее нужно так и описывать в коде
-- в [квадратных] скобках указаны необязательные переменные
```
---
>let's begin
## Асинхронное программирование
Немного о модели программирования для нашего шлюза. При проектировании алгоритмов лучше не использовать функции а-ля os.delay() и самописные аналоги, выполняющие паузы в работе сценария более 1 секунды. Вместо этого лучше проектировать вызовы кусков кода из разных скриптов. 

Например, часто при включении света в техническом или проходном помещении, необходимо сделать паузу и свет выключить. Первое, что приходит в голову - это сделать паузу в теле текущего сценария. Но, правильнее передать управление другому скрипту или вызвать основной [рекурсивно](/lua_doc/luaMainDoorLight.md).  
Об асинхронности в программировании можно почитать, например [здесь](https://habr.com/ru/company/jugru/blog/446562).

---
## Примеры кода
Все примеры скриптов собраны [здесь](/samples_rus.md)

---
## Редактор скриптов и отладка
Редактор скриптов, по совместительству с файловым менеджером предназначен для создания, удаления и редактирования файлов, в том числе и скриптов. 
Найти его можно в меню *Actions -> Files* (в старых версиях прошивки *Actions -> Scripts*).<!--	#ToDo - с какой версии прошивки? -->
![](/img/luaScriptEditor.png)
Редактор разделен на несколько областей:
- Меню, с кнопками:
  - *Toggle files* - скрыть / отобразить панель файлов
  - *Save* - сохранить
  - *Run* - запустить скрипт на исполнение
  - *Clear output* - очистить панель вывода
- Панель *Files*. Позволяет управлять файлами:
  - Создать - *New file*
  - Удалить - значок корзины напротив имени каждого файла
  - Открыть на редактирование - каждый файл представляет собой ссылку, по которой файл открывается в панели редактора
- Панель редактора
- Панель вывода - консоль для вывода результатов работы редактируемого скрипта

Скриптовый `stdout` функции LUA `print()` выводит информацию на Панель вывода, а также в системный лог (меню *Log*) шлюза. Данную функцию удобно использовать для отладки.

Для разработки или отладки скрипта, необходимо создать новый файл или открыть существующий. Например, с именем `test.lua` и в него ввести код на языке LUA. 

Отладка скриптов выполняется преимущественно в Редакторе скриптов SLS. Однако, некоторые пользовательские функции может быть удобнее разрабатывать во "взрослых" IDE. Например, нативный [ZeroBrain Studio](https://studio.zerobrane.com), VS Code, Atom и других. 

---
## Запуск скриптов
В зависимости от задач, выполняемых той или иной автоматизацией, доступны несколько вариантов запуска скриптов:
1. [из скрипта инициализации](/lua_rus.md#скрипт-инициализации)
2. [при изменении состояния устройства](/lua_rus.md#запуск-скрипта-при-изменении-состояния-устройства)
3. [по событию изменения объекта](/lua_rus.md#запуск-скрипта-по-событию-изменения-объекта) <!--	#ToDo - в документации вендора данный пункт ссылается на несуществующий раздел? -->
4. [запуск из другого скрипта](/lua_rus.md#запуск-lua-скрипта-из-другого-скрипта)
5. [с помощью  http api](/lua_rus.md#запуск-скрипта-с-помощью-http-api)
6. [периодический запуск (таймеры)](/lua_rus.md#периодический-запуск-скриптов-таймеры)
7. по подписке mqtt (в разработке).

### Скрипт инициализации
При запуске системы выполняется скрипт инициализации `init.lua`, если он есть. Перед началом работы со скриптами, рекомендуется проверить его наличие рядом со всеми остальными скриптами `*.lua`. Если файла нет, то его нужно в редакторе скриптов.  В `init.lua` полезно инициализировать переменные для работы с устройством, а также выполнить какие либо действия. [Например:](/samples_rus.md#скрипт-инициализации)
```lua
-- init.lua --
-- Уведомление в Telegram о старте шлюза --
telegram.settoken("51778***5:AAG0bvK***")
telegram.setchat("-3348***")
telegram.send("SLS загружен!!!")
```

### Запуск скрипта при изменении состояния устройства
Скрипт можно запускать как одно из правил [SimpleBind](/simplebind_rus.md).

Синтаксис: `scriptname.lua[,Param]`

Например, так может выглядеть запись SB Rule для датчика открытия ![](/img/luaSBRule.png)
- `mainDoorOnLight.lua` - имя запускаемого скрипта
- `Param` - необязательный параметр, через который в скрипт можно передать необходимые аргументы. Принимается он в скрипте через Событие `Event.Param`
Аргументов может быть несколько. В данном примере передается 3 аргумента, разделенные символом `:`: целевое устройство, которым должен управлять датчик по сработке; контролируемый статус; задержка управляющего действия. Если аргументы не прописывать, то при изменении условий, придется менять эти значения в теле скрипта. Пример похожего скрипта [здесь](/lua_doc/luaMainDoorLight.md)

### Запуск скрипта по событию изменения объекта
Привязка к объекту скрипта, который будет выполняться при каждом изменении объекта
```lua
obj.onChange("Name"(STR), "script.lua"(STR))
-- Name - имя объекта
-- script.lua - имя файла скрипта с расширением
```
Данные объекта в вызываемый скрипт передаются через событие с типом `SCRIPT_EVENT_TYPE_OBJ_CHANGE` и значением `2`. Получить данные можно, например, так:
```lua
if Event.Type == 2 then
  local Name = Event.Obj.Name -- имя объекта
  local Value = Event.Obj.Value -- значение 
  local OldValue = Event.Obj.OldValue -- предыдущее значение
  local Ack = Event.Obj.Ack -- статус флага обратной связи
end
```
 
### Запуск LUA скрипта из другого скрипта

Синтаксис: `dofile("/int/script.lua"[, Param])`
<!-- ToDo добавить параметры, если они есть -->

### Запуск скрипта с помощью HTTP API

Скрипт SLS можно вызвать из внешней системы используя [HTTP API](/http_api_rus.md):
`/api/scripts?action=evalFile&path=/test.lua`

### Периодический запуск скриптов из планировщика
Шлюз может запускать скрипты с определенной периодичностью. Можно установить таймер запуска к любому скрипту, а так же отменить его. Дискретность таймеров 1 секунда, для Cron - 1 минута.

Типы таймеров:
- Периодический. Выполняется каждые `X` секунд. `Event.Type = 5`
  ```lua
  scripts.setTimer("script"(STR), t(INT)[, "Param"(STR)])
  -- script - имя файла скрипта, без расширения `lua`
  -- t - уставка времени в сек. Для сброса таймера: `t = 0`
  -- Param - аргументы, передаваемые в скрипт
  ```
- Однократный.  Выполняется однократно в UNIX время. `Event.Type = 4`
  ```lua
  scripts.setTimer("script"(STR), os.time() + t(INT)[, "Param"(STR)])
  -- script - имя файла скрипта, без расширения `lua`
  -- os.time() - функциия LUA, возвращает UNIX время на текущий момент в сек.
  -- t - уставка времени в сек. Для сброса таймера: `t = 0`
  -- Param - аргументы, передаваемые в скрипт
  ```
- Cron. `Event.Type = 6`. Добавлен в версии прошивки 2022.04.24d11. Синтаксис как у [UNIX cron](https://ru.wikipedia.org/wiki/Cron) 
```lua
  scripts.setTimer("script"(STR), "crontab"(STR)[, "Param"(STR)])
  -- script - имя файла скрипта, без расширения `lua`
  -- crontab - уставка времени в формате UNIX CRON 
  --[[ TODO - проверить есть ли здесь поддержка Param]]
```
[Примеры](/samples_rus.md#таймеры)

Если выполнить подряд несколько установок таймера для одного целевого скрипта, то настройка применяется из последней итерации.

Например, скрипт привязан к датчику движения и при каждой сработке настраивает однократный таймер запуска исполняющего скрипта. При этом, если основной скрипт успевает запуститься несколько раз до сработки таймера, то уставка времени будет из последней итерации. 

**Внимание, скрипты OneMinTimer.lua и OneSecTimer.lua более не запускаются автоматически!!! (с версии прошивки 2022.01.30d1)**

---
## Библиотеки SLS
В прошивку шлюза встроены следующие библиотеки:
- [obj.](/lua_rus.md#Библиотека-OBJ) - работа с объектами
- [Event.](/lua_rus.md#Библиотека-event) - работа с событиями
- [zigbee.](/lua_rus.md#библиотека-zigbee) - управление zigbee устройствами 
- [mqtt.](/lua_rus.md#библиотека-mqtt) - работа с MQTT брокером
- [http.](/lua_rus.md#библиотека-http) - взаимодействие с внешними системами по HTTP
- [telegram.](/lua_rus.md#) - отправка уведомлений и управление шлюзом
- [os.](/lua_rus.md#) - взаимодействие с операционной системой шлюза. [Работа с хранилищем](/storage_rus.md)
- [gpio.](/lua_rus.md#Библиотека-GPIO) - управление GPIO
- [audio.](/lua_rus.md#Библиотека-audio) - управление встроенным в шлюза звуком
- [net.](/lua_rus.md#Библиотека-net) - получение IP адресов шлюза

[Примеры использования](/samples_rus.md).

### Библиотека OBJ
Объекты это универсальная сущность для хранения и обмена данными между подсистемами шлюза, например между скриптами. [Подробнее здесь](/objects_rus.md). [Примеры](/samples_rus.md).

Синтаксис функций:
#### obj.setOpt()
Инициализация объекта, изменения типа данных, записываемых в объект, управление флагом передачи уведомлений в MQTT
```lua
obj.setOpt("Name"(STR), "type"(STR)[, flagMQTT(BOOL)])
-- Name - имя объекта
-- type - тип хранимых данных: STR, INT, BOOL, FLOAT
-- flagMQTT - флаг передачи уведомлений в MQTT
  -- false = передача выключена
  -- true = передача включена. В таблице объектов (WebUI/Objects) отображается сомволом N (Notify)
```
#### obj.set()
Запись данных в объект, управление флагом обратной связи. При первом вызове - инициализация объекта.
```lua
obj.set("Name"(STR), value[, flagACK(BOOL)])
-- Name - имя объекта
-- value - записываемые данные, любого типа
-- flagACK - флаг обратной связи
  -- true = включен. В таблице объектов отображается символом A (ACK)
  -- false = выключен. В таблице объектов не отображается
```
#### obj.get()
Получение данных, хранящихся в объекте
```lua
obj.get("Name"(STR))
-- Name - имя объекта
```
В объекте хранится текущее значение, предыдущее и состояние флага ACK. Также хранится тайм-штампы записи текущего значения  и предыдущего, которые можно получить следующей функцией. Для получения всех значений можно использовать такой код:
```lua
current_value, previos_value, flag_ack = obj.get("object_name")
-- переменные будут содержать:
-- current_value = текущее значение
-- previos_value = предыдущее значение
-- flag_ack = статус флага ACK 
```
#### obj.getTime()
Получение тайм-штампов изменения текущего и предыдущего значений. Оба значения можно получить так-же как в `obj.get()`
```lua
obj.getTime("Name"(STR))
-- имя объекта
```
#### obj.onChange()
Привязка к объекту скрипта, который будет выполняться при каждом изменении объекта
```lua
obj.onChange("Name"(STR), "script.lua"(STR))
-- Name - имя объекта
-- script.lua - имя файла скрипта с расширением
```
#### obj.remove()
Удаление объекта
```lua
obj.remove("Name"(STR))
-- Name - имя объекта
```
### Библиотека EVENT
Библиотека `Event` служит для передачи данных в скрипт, в зависимости от того, из какой подсистемы он вызван.
### Типы событий
События различаются типом `Event.Type`. В скрипт передается числовое значение типа события, позволяющее определить источник вызова и получить различные параметры:

1. [Вызов по изменению состояния привязанного сенсора](/lua_rus.md#Вызов-из-SB-Rule). Правило Simple Bind. 
2. [Вызов по изменению объекта](/lua_rus.md#Вызов-по-изменению-объекта). `SCRIPT_EVENT_TYPE_OBJ_CHANGE` 
3.  
4. [Таймер однократный.](/lua_rus.md#Вызов-по-однократному-таймеру)
5. [Таймер периодический.](/lua_rus.md#Вызов-по-периодическому-таймеру)
6. [Таймер Cron.](/lua_rus.md#Вызов-по-таймеру-Cron)
### Свойства событий
Для всех типов событий передаются следующие свойства:
- `Event.Type` - тип события INT
- `Event.Name` - имя файла вызванного скрипта с расширением
- `Event.Time` - время вызова скрипта `table(sec, min, hour, day, wday, month, year)`. 

#### Вызов из SB Rule
- `Event.Param` - аргументы
- `Event.nwkAddr` - nwkAddr вызывающего устройства
- `Event.ieeeAddr` - ieeeAddr вызывающего устройства
- `Event.ModelId` - ModelId вызывающего устройства
- `Event.FriendlyName` - FriendlyName вызывающего устройства
- `Event.State.Name` - имя вызывающего "состояния"
- `Event.State.Value` - текущее значение "состояния"
- `Event.State.OldValue` - предыдущее значение "состояния"

#### Вызов по изменению объекта
- `Event.Obj.Name` - имя объекта, который вызвал скрипт
- `Event.Obj.Ack` - флаг обратной связи объекта
- `Event.Obj.Value` - текущее значение
- `Event.Obj.OldValue` - предыдущее значение

#### Вызов по однократному таймеру
- `Event.Param` - аргументы

#### Вызов по периодическому таймеру
- `Event.Param` - аргументы

#### Вызов по таймеру Cron 
<!-- - `Event.Param` - аргументы -->

### Библиотека ZIGBEE
Служит для управления zigbee устройствами, зарегистрированными на шлюзе. Подробные примеры [здесь](/samples_rus.md#zigbee)

#### zigbee.getStatus()
Возвращает статус координатора. Если запущен, вернёт 9.
Начиная с версии 2022.07.24d1.
```lua
-- пример
coord_status = zigbee.getStatus()
```
#### zigbee.join()
Включает режим сопряжения для подключения новых устройств
```lua
zigbee.join(duration(INT)[, "router"(STR)])
-- duration - время в секундах, на которое включить Join
-- router - FriendlyName, ieeeAddr или nwkAddr устройства - роутера. Если опустить этот параметр, сопряжение будет открыто для всей сети
```
#### zigbee.value()
Возвращает значения состояния устройства из кэша 
```lua
zigbee.value("device"(STR), "state"(STR))
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- state - состояние, значение которого необходимо получить
```
#### zigbee.get()
Возвращает значения состояния устройства вызовом функции GET в конвертере
```lua
zigbee.get("device"(STR), "state"(STR))
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- state - состояние, значение которого необходимо получить
```
#### zigbee.set()
Устанавливает значение состояния устройства
```lua
zigbee.set("device"(STR), "stateName"(STR), stateValue)
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- stateName - имя состояния, значение которого необходимо изменить
-- stateValue - значение состояние. Тип - свой для каждого значения. Например, для кнопки State:Action тип будет STR, а для яркости State:brightness тип будет INT 
```
#### zigbee.setState()
Устанавливает значение состояния устройства. Можно указать тип значения (по умолчанию STR) и необходимо ли выполнять события (с версии 2022.07.24d1, по умолчанию true) .
В отличие от `zigbee.set()` позволяет создавать свои состояния, виртуальные. [Например](/samples_rus.md#Преобразование-показателей-давления-из-kPa-в-mmhg), для хранения данных какого-либо состояния, в альтернативных единицах измерения. 
```lua
zigbee.setState("device"(STR), "stateName"(STR), stateValue[[, "type"(STR)], events(BOOL)])
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- stateName - имя состояния, значение которого необходимо изменить
-- stateValue - значение состояние
-- type - тип значений состояния
-- events - выполнять события (по умолчанию true)
```
<!-- TODO - setState скудно описан. Разобраться. По идее нужен для создания кастомных стэйтов и вроде как устройств и управлении ими. При этом управляется также и через set(), но как-то криво, например: есть color_temp, создал color_temp1. При изменении color_temp1 через set() - меняется также и color_temp. Как удалить созданного стэйта. Разобраться с флагом events. Как читать состояние флага?  -->

#### zigbee.setModel()
Программное переназначение типа устройства. 
```lua
zigbee.setModel("device"(STR), "ModelId"(STR))
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- ModelId - ModelId устройства, которое поддерживается шлюзом.
```
В некоторых случаях протокол взаимодействия новых устройств совпадает с теми, что уже поддерживаются шлюзом SLS. В таком случае можно при загрузке шлюза подменять идентификаторы, добавив в init.lua код:
```lua
zigbee.setModel("xBox", "ptvo.switch")
```
**Данный функционал будет полезен пользователям генератора прошивок ptvo, кто самостоятельно изменит имя устройства на кастомное.**

#### zigbee.readAttr()
Отправляет запрос на чтение атрибута в кластере.
```lua
zigbee.readAttr("device"(STR), epId(NUMBER), clusterId(NUMBER), AttrId(NUMBER)[, manufId])
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- epID - номер эндпоинта
-- clusterID - номер кластера
-- AttrId - номер атрибута
-- Например, вернуть атрибут swBuild в кластере genBasic в 1 эндпоинте:
zigbee.readAttr("0x90FD9FFFFEF7E26D", 1, 0x4000, 0x0000)
```
> функционал и его описание в разработке <!-- todo -->

#### zigbee.writeAttr()
Записывает значение атрибута в кластере.
```lua
zigbee.writeAttr("device"(STR), epId(NUMBER), clusterId(NUMBER), AttrId(NUMBER), "dataType"(STR), value[, manufId])
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- epID - номер эндпоинта
-- clusterID - номер кластера
-- AttrId - номер атрибута
-- dataType - тип данных
-- value - значение атрибута
```
> функционал и его описание в разработке <!-- todo -->

#### zigbee.configReport()
Конфигурирует репортинг атрибута в кластере.
```lua
zigbee.configReport("device"(STR), epId(NUMBER), clusterId(NUMBER), AttrId(NUMBER), "dataType"(STR), minRepInt(INT), maxRepInt(INT), repChange(BOOL))
-- device - FriendlyName, ieeeAddr или nwkAddr устройства
-- epID - номер эндпоинта
-- clusterID - номер кластера
-- AttrId - номер атрибута
-- dataType - тип данных
-- minRepInt
-- maxRepInt
-- repChange
```
> функционал и его описание в разработке <!-- todo -->
<!-- 
#### zigbee.addInstallCode()
todo - в разработке
#### zigbee.configConv()
todo - в разработке
#### zigbee.setRetain()
todo - в разработке
#### zigbee.setsaveinterval()
todo - в разработке
 -->

### Библиотека MQTT
#### mqtt.pub()
Публикует на MQTT сервер в топик *topic* значение *payload*. 
```lua
mqtt.pub("topic"(STR), "payload"(STR))
```
Пример управления реле на прошивке Tasmota - `cmnd/имя устройства/имя реле`
```lua
mqtt.pub('cmnd/sonoff5/power', 'toggle')
```

#### mqtt.connected()
Возвращает статус подключение к брокеру MQTT. Выполняется без параметров.

#### mqtt.sub()
Подписывается на топик и помещает полученные значения в объект. Можно вызывать повторно с другим именем объекта, для его изменения.
```lua
mqtt.sub("topic"(STR), "objName"(STR))
-- topic - топик MQTT
-- objName - объект, в который записываются данные
```
Пример подписки на топик с температурой, которую шлюз помещает в объект:
```lua
mqtt.sub('dev/sensor/temp', 'room_temp')
```

#### mqtt.unSub()
Отписывается от топика.
```lua
mqtt.unSub("topic"(STR))
```
Пример отписки от топика с температурой
```lua
mqtt.unSub('dev/sensor/temp')
```
### Библиотека HTTP
#### http.request2()
Служит для отправки HTTP (HTTPS в разработке) запросов во внешние системы. Поддерживает методы GET и POST.
```lua
http.request ("url"(STR)[:"port"(STR)], ["method"(STR), "headers"(STR), "body"(STR)]`)
-- url:port - URL адрес и порт целевого ресурса
-- method - метод POST или GET
-- headers - заголовки запроса
-- body - тело запроса
```
[Примеры](/samples_rus.md#HTTP-запросы)
Предыдущая версия функции: `http.request()` имеет такой же синтаксис и для обратной совместимости, также доступна.

### Библиотека OS

[Примеры](/samples_rus.md#Библиотека-OS)

#### os.time()
Возвращает Unix время. Вызывается без параметров.

#### os.sunrise([offset])
Возвращает время восхода солнца (часы, минуты). Для правильной работы требуется выполнить настройки *Settings -> Time & Location*
```lua
os.sunrise([offset])
-- offset - позволяет добавить смещение в минутах к результату вывода
-- Пример:
sunriseH, sunriseM = os.sunrise()
print("Восход солнца в " .. sunriseH .. ":" .. sunriseM )
--[[ Вывод 
  Восход солнца в 10:55
--]]
```
#### os.sunset([offset])
Возвращает время заката солнца (часы, минуты). Для правильной работы требуется выполнить настройки *Settings -> Time & Location*
```lua
os.sunset([offset])
-- offset - позволяет добавить смещение в минутах к результату вывода
-- Пример:
sunsetH, sunsetM = os.sunset(69)
```
#### os.setSleep()
Включает и выключает режим сна для модема WiFi. По-умолчанию выключено. Также можно заставить систему заснуть глубоким сном на `time` секунд, тем самым снизив энергопотребление практически до нуля. В этом режиме не работает ничего, кроме таймера отсчета до окончания сна, по прошествии которого система перезагрузится. Это может использоваться при питании от аккумулятора.
```lua
os.setSleep(enable(BOOL)[,time(INT)])
-- enable - включить = true, выключить = false спящий режим
-- time - время сна в сек.
```
#### os.delay()
Выполняет паузу выполнения скрипта на указанное время. Не рекомендуется делать паузу более чем на 1 секунду.
```lua
os.delay(time(INT))
-- time - время паузы в милисекундах (1 сек = 1000 мс)
```
#### os.millis()
Возвращает количество миллисекунд с момента загрузки системы. Вызывается без параметров.

#### os.getUptime()
Возвращает время с момента загрузки системы. Вызывается без параметров.
```lua
-- пример кода
print('Uptime: ' .. os.getUptime())
--[[ Пример вывода
  Uptime: 11 days 17:43:03
--]]
```
#### os.ntp()
Возвращает статус подключение к серверу времени (NTP): `true` - синхронизация с сервером NTP выполнена успешно. Вызывается без параметров.

#### os.freeMem()
Возвращает количество свободной памяти в байтах.
```lua
os.freeMem(["type"(STR)])
-- type - heap, psram
-- без параметров возвращает объем FreeHeap
```
#### os.save()
Сохраняет данные. Тоже, что и меню *Actions -> Save*. Вызывается без параметров.

#### os.restart()
Перезагружает ОС. Вызывается без параметров.

#### os.ping()
Отправляет запросы ICMP PING на тестируемый хост. Возвращает среднее время ответа или -1 при недоступности.
```lua
os.ping("host"(STR)[, count(INT)])
-- host - IP или DNS адрес хоста
-- count - количество запрсов (по-умолчанию 1)
```
#### os.led()
SLS шлюз может управлять различными  светодиодами. Это может быть подсветка корпуса Xiaomi, круглые платы с modkam.ru, либо индикационный многофункциональный светодиод шлюза SLS DIN MINI. В дополнение можно подключить обычную светодиодную ленту. Описание параметров:
```lua
os.led(mode(STR), brightness(INT), r(INT), g(INT), b(INT)[, effect])
-- mode - режим. OFF - выключено, ON - включено, AUTO - индикация режимов/состояний шлюза (см. описаниее далее) 
-- brightness - яркость (целое, от 0 до 255)
-- r, g, b - цвет (целое, от 0 до 255 или -1, если цвет менять не требуется)
-- effect - включает эффекты в соответствии с таблицей

``` 
В режиме AUTO шлюз оповещает о своем состоянии по следующему алгоритму: 
- зеленый горит - Join
- синий переливается - режим AP
- синий мигает - идет подключение к Wi-Fi
- красный - ошибка подключения к Wi-Fi

[Таблица эффектов](/led_effects.md)

[Примеры для различных устройств](/samples_rus.md#Управление-адресными-светодиодами)

Альтернативный вариант управления через [HTTP API](/http_api_rus.md#leds)

#### os.wdt()
Включается и выключает WDT (Сторожевой таймер), может использоваться для отладки незапланированных перезагрузок.
```lua
os.wdt(enable(BOOL))
-- enable - включить (true), выключить (false) 
```
## os.udplogenable()
Включает логирование через UDP. [Примеры получения лога](/faq_rus.md#включение-udp-log)
```lua
os.udplogenable(enable(BOOL))
-- enable - включить UDP лог (true); выключить (false)
```
#### os.mountSD()
Монтирует SD-карту
```lua
os.mountSD(mount(BOOL))
-- mount - примонтировать = true; размонтировать = false
```
#### os.fileExists()
Проверяет наличие файла, возвращает true/false
```lua
os.fileExists("fileName"(STR))
-- fileName - имя проверяемого файла
```
#### os.fileRemove()
Удаляет файл
```lua
os.fileRemove("fileName"(STR))
-- fileName - имя удаляемого файла
```
#### os.fileRename()
Переименовывает файл
```lua
os.fileRename("old"(STR), "new"(STR))
-- old - старое имя переимновываемого файла
-- new - новое имя переимновываемого файла
```
#### os.readFile()
Читает файл 
```lua
os.readFile("fileName"(STR))
-- fileName - имя целевого файла
```
#### os.writeFile()
Записывает данные в файл:
```lua
os.writeFile("fileName"(STR),"data"(STR)[, overwrite(BOOL)])
-- fileName - имя целевого файла
-- data - данные
-- overwrite - перезаписать файл (true)
-- Пример:
os.writeFile("/int/!file.db","привет\n",true)
-- Для карты памяти необходимо использовать путь "/sd/file.txt"
```
#### os.setAssets()
Задает место хранения скриптов web-интерфейса, для размещения во внутреннем хранилище или на карте памяти для систем без выхода в интернет  (в разработке).

###  Библиотека GPIO
Управление пинами ввода/вывода шлюза (GPIO)
```lua
gpio.mode(pin, mode)
gpio.read(pin) - чтение цифрового 
gpio.read(PIN, true) - чтение ADC
gpio.write(pin, level)
```
<!-- TODO - надо собирать по всем докам -->

### Библиотека AUDIO
Управление звуком
```lua
audio.playurl(url) -- проигрывание звука из URL
audio.geturl() --- возвращает текущий URL
audio.stop() -- остановить проигрывание
audio.setvolume(volume_procent) -- установить уровень громкости
audio.getvolume() -- возвращает текущий уровень громкости
audio.getstatus() -- возвращает текущий статус
```

### Библиотека NET
#### net.localIP() 
Возвращает адрес устройства SLS в локальной сети. Выполняется без параметров.
#### net.remoteIP()  
Возвращает внешний адрес SLS в сети интернет (если доступен). Выполняется без параметров.

## Функции LUA SLS
Функции LUA, встроенные в прошивку SLS, которые не объединены той или иной библиотекой.
### explode()
Разбивает строку с помощью разделителя. Результат помещает в массив.
```lua
explode("string"(STR), "separator"(STR))
-- string - строка, которую необходимо разбить
-- separator - символ разделителя
-- пример:
local string = "param1|param2|param3"
local t = explode(string, "|")
local param1 = t[1]
local param2 = t[2]
local param3 = t[3]
```

## Обработка нажатий аппаратной кнопки шлюза
Многие ревизии шлюзов имеют кнопку, нажатия которой можно обрабатывать скриптами. Например, для включения "режима сопряжения" при нажатии на боковую кнопку  шлюза
Необходимо привязать скрипт `btn_sw1.lua`
```lua
zigbee.join(255, "0x0000")
```
и привязать его выполнение в init.lua
```lua
obj.onChange("io.input0.value", "btn_sw1.lua")
```
- где `io.input0.value` - номер обрататываемого порта (в примере указана кнопка для круглого шлюза)

Более подробно вопрос с обрабокой событий gpio разобран в разделе [Модуля ввода-вывода](/devices/din_mini_io_rus.md)
  
## Полезные ссылки 
1) [Примеры типовых сценариев](/samples_rus.md) 
2) On-line учебник по [lua](https://zserge.wordpress.com/2012/02/23/lua-%D0%B7%D0%B0-60-%D0%BC%D0%B8%D0%BD%D1%83%D1%82/)
3) Генератор lua скриптов  на основе [Blockly](https://blockly-demo.appspot.com/static/demos/code/index.html)



