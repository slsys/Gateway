# Модуль ввода-вывода
Плата расширения IO-board для [SLS DIN MINI](/devices/din_mini_base_rus.md) предоставляет 6 независимых каналов. Позволяет подключать счетчики, герконы, концевики, производить управление другими устройствами. Настройка и инициализация производится lua скриптами. 

![IO](/devices/images/ioboard.png)

Возможны следующие режимы работы каналов:

* Вход: сухой контакт (Срабатывает при замыкании входа на GND)

* Выход: транзисторный с поддержкой ШИМ (Ток течет между + питания и выходом)

## Выбор аппаратного режима работы порта
Для выбора аппаратного режима используются перемычки на плате.

* Вверх - выход.

* Вниз - вход.

## Инициализация
### Определение GPIO

В SLS DIN MINI GPIO распределены следующим порядков:
* Канал 1: GPIO32
* Канал 2: GPIO25
* Канал 3: GPIO26
* Канал 4: GPIO27
* Канал 5: GPIO12
* Канал 6: GPIO13

Определение режима прописывается  командой ```gpio.addInput(GPIO, [gpio.INPUT,gpio.OUTPUT] , mode, "name")```   через редактор скиптов в файле  *init.lua*, процедура проводится  однократно.
init.lua:
```lua 
--определяем режим работы портов
gpio.addInput(32, gpio.INPUT_PULLUP, 0, "input1")                  -- Вход 1, gpio 32  (датчик заполненного сэптика)
gpio.addInput(25, gpio.INPUT_PULLUP, 0, "input2")                  -- Вход 2, gpio 25  (геркон калитки)
gpio.addInput(26, gpio.INPUT_PULLUP, 2, "input3")                  -- Вход 3, gpio 26  
gpio.addInput(27, gpio.INPUT_PULLUP, 0, "input4", 100, 200, 300)   -- Вход 4, gpio 27   (геркон ворот)
gpio.addInput(12, gpio.INPUT_PULLUP, 2, "input5")                  -- Вход 5, gpio 12
gpio.addInput(13, gpio.INPUT_PULLUP, 2, "input6")                  -- Вход 6, gpio 13
----------
obj.setOpt('septik','STR',true) -- для удобства работы создадим объект septik и настроим отправку состояния в mqtt (true)
----------
--- определяем действия, которые необходимо выполнять при изменении значений портов
obj.onChange('io.input4.value', 'vorota.lua')  -- при изменении io.input4.value выполним скрипт vorota.lua
obj.onChange('io.input2.value', 'vorota.lua')  -- при изменении io.input4.value выполним скрипт vorota.lua
obj.onChange('io.input1.value', 'septik.lua')  -- при изменении io.input4.value выполним скрипт vorota.lua
scripts.setTimer("septik", os.time() + 5)      -- запустим скрипт чтения состояния сэптика при запуске SLS
```

Пример скрипта опроса состояния сэптика septik.lua (запускается при включении SLS  и изменении gpio:
```lua
  local septik = gpio.read(32)           --опредеяем порт для чтения состояния
  if septik == 1  then  
    telegram.send("#Сэптик очищен")      --отправляем сообщение в телеграм
  obj.set("septik", "empty")             --задаем состояние объекта (для удобства работы)
  end
  if septik == 0  then  
  obj.set("septik", "full")          
  telegram.send("#Сэптик заполнен") end  --отправляем сообщение в телеграм
  ```

### Выбор программного режима работы (mode)

Переназнчаить  режима работы порта можно  функцией *gpio.mode(GPIO, mode)*, где mode может быть *gpio.INPUT* или *gpio.OUTPUT*.

| mode | Режим | Описание |
|-|-|-|
|0|SWITCH| В данном режиме шлюз контролирует текущее состояние входа, поэтому в этом режиме можно подключать датчики откр., движ., протечек, клас-е выкл. с фиксацией.|
|1|COUNTER| Простой подсчет событий, новое событие фиксируется по состоянию разыкания контакта, можно подключать например счетчики воды, газа и др.|
|2|MULTI_SWITCH|Предназначен для подключения выкл. без фиксации. Поддерживает следующие события: короткие (одиночное, двойное, тройное, четверное, и так до 255), длительное, короткое, а затем длительное, а так же завершение длительного нажатия. При завершении длительного фиксируется его длительность. Итого 767 разных событий. Можно строить очень сложную логику, имея всего 1 кнопку!|
|3|MOMENTARY| Режим фиксирует без задержки, присущей режиму MULTI_SWITCH события нажатия и отпускания кнопки без фиксации, при этом при отпускании фиксируется дл-сть нажатия.|
|4|TOGGLE|Для кнопок без фиксации, каждое нажатие переключает состояние входа.|

### Примеры использования
Задать каналу 2 режим входа, получить его значение:
```lua
gpio.mode(25, gpio.INPUT)
local value = gpio.read(25)
print(value)
```
Задать каналу 4 режим выхода и включить его:
```lua
gpio.mode(27, gpio.OUTPUT)
gpio.write(27, 1)
```
Задать каналу 1 режим выхода и включить ШИМ со скважностью 50%:
```lua
gpio.mode(32, gpio.OUTPUT)
gpio.pwmsetup(3, 32)
gpio.pwm(3, 255/100*50)
```
Задать каналу 4 режим выхода и включить его на 100мс:
```lua
gpio.mode(27, gpio.OUTPUT)
gpio.write(27, 1)
os.delay(100)
gpio.write(27, 0)
```



Включить режим входа MultiSwitch на 1 канале:
```lua
gpio.addInput(32, gpio.INPUT_PULLUP, 2, "input1")
```

Включить режим входа MultiSwitch на сервисной кнопке и изменить тайминги debounce, send и hold:
```lua
-- Стандартные тайминги: debounce = 50, send = 300 и hold = 1000
gpio.addInput(33, gpio.INPUT_PULLUP, 2, "input0", 100, 500, 2000)
```

Добавить все входы модуля в режиме MultiSwitch:
```lua
gpio.addInput(32, gpio.INPUT_PULLUP, 2, "input1")
gpio.addInput(25, gpio.INPUT_PULLUP, 2, "input2")
gpio.addInput(26, gpio.INPUT_PULLUP, 2, "input3")
gpio.addInput(27, gpio.INPUT_PULLUP, 2, "input4")
gpio.addInput(12, gpio.INPUT_PULLUP, 2, "input5")
gpio.addInput(13, gpio.INPUT_PULLUP, 2, "input6")
```

## Полезные ссылки 
[Использования GPIO на примерах решаемых задач](/gpio_sample_rus.md)



