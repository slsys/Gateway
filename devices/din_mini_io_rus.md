# Модуль ввода-вывода

Плата расширения IO-board для [SLS DIN MINI](/devices/din_mini_base_rus.md) предоставляет 6 независимых каналов. Позволяет подключать счетчики, герконы, концевики, производить управление другими устройствами. Настройка и инициализация производится lua скриптами.

![IO](/devices/images/ioboard.png)

Возможны следующие режимы работы каналов:

- Вход: сухой контакт (Срабатывает при замыкании входа на GND)

- Выход: транзисторный с поддержкой ШИМ (Ток течет между GND питания и выходом)

## Выбор аппаратного режима работы порта

Для выбора аппаратного режима используются перемычки на плате.

- Вверх - выход.

- Вниз - вход.

## Инициализация

### Определение GPIO

В SLS DIN MINI GPIO распределены следующим порядков:

- Канал 1: GPIO32
- Канал 2: GPIO25
- Канал 3: GPIO26
- Канал 4: GPIO27
- Канал 5: GPIO12
- Канал 6: GPIO13

Определение режима прописывается командой `io.addGPIOInput("name", GPIO, [gpio.INPUT,gpio.OUTPUT] , mode)` через редактор скриптов в файле _init.lua_, процедура проводится однократно.
init.lua:

```lua
--определяем режим работы портов
gpio.addInput(32, gpio.INPUT_PULLUP, 0, "input1")                  -- Вход 1, gpio 32  (датчик заполненного септика)
gpio.addInput(25, gpio.INPUT_PULLUP, 0, "input2")                  -- Вход 2, gpio 25  (геркон калитки)
gpio.addInput(26, gpio.INPUT_PULLUP, 2, "input3")                  -- Вход 3, gpio 26
gpio.addInput(27, gpio.INPUT_PULLUP, 0, "input4", 100, 200, 300)   -- Вход 4, gpio 27   (геркон ворот)
gpio.addInput(12, gpio.INPUT_PULLUP, 2, "input5")                  -- Вход 5, gpio 12
gpio.addInput(13, gpio.INPUT_PULLUP, 2, "input6")                  -- Вход 6, gpio 13
----------
obj.setOpt('septik','STR',true) -- для удобства работы создадим объект septik и настроим отправку состояния в mqtt (true)
----------
--- определяем действия, которые необходимо выполнять при изменении значений портов
obj.onChange('io.input4.value', 'vorota.lua')  -- при изменении io.input4.value выполним скрипт vorota.lua
obj.onChange('io.input2.value', 'vorota.lua')  -- при изменении io.input4.value выполним скрипт vorota.lua
obj.onChange('io.input1.value', 'septik.lua')  -- при изменении io.input4.value выполним скрипт vorota.lua
scripts.setTimer("septik", os.time() + 5)      -- запустим скрипт чтения состояния септика при запуске SLS
```

Пример скрипта опроса состояния сэптика septik.lua (запускается при включении SLS и изменении gpio:

```lua
  local septik = gpio.read(32)           --определяем порт для чтения состояния
  if septik == 1  then
    telegram.send("#Септик очищен")      --отправляем сообщение в телеграм
  obj.set("septik", "empty")             --задаем состояние объекта (для удобства работы)
  end
  if septik == 0  then
  obj.set("septik", "full")
  telegram.send("#Септик заполнен") end  --отправляем сообщение в телеграм
```

### Выбор программного режима работы (mode)

Переназначить режим работы порта можно функцией _gpio.mode(GPIO, mode)_, где mode может быть _gpio.INPUT_ или _gpio.OUTPUT_.

| mode | Режим        | Описание                                                                                                                                                                                                                                                                                                                                                                         |
| ---- | ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0    | SWITCH       | В данном режиме шлюз контролирует текущее состояние входа, поэтому в этом режиме можно подключать датчики откр., движ., протечек, клас-е выкл. с фиксацией.                                                                                                                                                                                                                      |
| 1    | COUNTER      | Простой подсчет событий, новое событие фиксируется по состоянию размыкания контакта, можно подключать например счетчики воды, газа и др.                                                                                                                                                                                                                                          |
| 2    | MULTI_SWITCH | Предназначен для подключения выкл. без фиксации. Поддерживает следующие события: короткие (одиночное, двойное, тройное, четверное, и так до 255), длительное, короткое, а затем длительное, а так же завершение длительного нажатия. При завершении длительного фиксируется его длительность. Итого 767 разных событий. Можно строить очень сложную логику, имея всего 1 кнопку! |
| 3    | MOMENTARY    | Режим фиксирует без задержки, присущей режиму MULTI_SWITCH события нажатия и отпускания кнопки без фиксации, при этом при отпускании фиксируется дл-сть нажатия.                                                                                                                                                                                                                 |
| 4    | TOGGLE       | Для кнопок без фиксации, каждое нажатие переключает состояние входа.                                                                                                                                                                                                                                                                                                             |

### Примеры использования

Задать каналу 2 режим входа, получить его значение:

```lua
gpio.mode(25, gpio.INPUT)
local value = gpio.read(25)
print(value)
```

Задать каналу 4 режим выхода и включить его:

```lua
gpio.mode(27, gpio.OUTPUT)
gpio.write(27, 1)
```

Задать каналу 1 режим выхода и включить ШИМ со скважностью 50%:

```lua
gpio.mode(32, gpio.OUTPUT)
gpio.pwmsetup(3, 32)
gpio.pwm(3, 255/100*50)
```

Задать каналу 4 режим выхода и включить его на 100мс:

```lua
gpio.mode(27, gpio.OUTPUT)
gpio.write(27, 1)
os.delay(100)
gpio.write(27, 0)
```

Включить режим входа MultiSwitch на 1 канале:

```lua
gpio.addInput(32, gpio.INPUT_PULLUP, 2, "input1")
```

Включить режим входа MultiSwitch на сервисной кнопке и изменить тайминги debounce, send и hold:

```lua
-- Стандартные тайминги: debounce = 50, send = 300 и hold = 1000
gpio.addInput(33, gpio.INPUT_PULLUP, 2, "input0", 100, 500, 2000)
```

Добавить все входы модуля в режиме MultiSwitch:

```lua
require "io"

io.begin(false)

io.addGPIOInput("in1", 32, gpio.INPUT_PULLUP, 2)
io.addGPIOInput("in2", 25, gpio.INPUT_PULLUP, 2)
io.addGPIOInput("in3", 26, gpio.INPUT_PULLUP, 2)
io.addGPIOInput("in4", 27, gpio.INPUT_PULLUP, 2)
io.addGPIOInput("in5", 12, gpio.INPUT_PULLUP, 2)
io.addGPIOInput("in6", 13, gpio.INPUT_PULLUP, 2)
```

## Полезные ссылки

[Использования GPIO на примерах решаемых задач](/gpio_sample.md)
